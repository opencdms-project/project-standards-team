$STORAGE:2
$DEBUG
C     PROGRAM MRGTWF
C
C
C     THE PROGRAM ALLOWS TO MERGE TWO KEY-ENTRY FILES INTO ONE FILE OR LIST
C     THE RECORD ID'S IN KEY-ENTRY FILE.  BOTH SOURCE AND TARGET KEY-ENTRY
C     FILES MUST HAVE THE SAME FORMAT.  tTHE NUMBER OF ELEMENTS AND ELEMENTS
C     CODES IN BOTH KEY-ENTRY FILES MUST BE IDENTICAL AND IN THE SAME ORDER.
C     AFTER PROGRAM MERGE, THE DATASET-ID OF SOURCE KEY-ENTRY FILE WILL BE
C     THE DATASET-ID OF THE TARGET KEY-ENTRY FILE THAT YOU SPECIFIED.
C
C     THE PROGRAM WILL VERIFY BOTH KEY-ENTRY FILES BEFORE IT MERGES AND
C     REQUIRES THE SOURCE KEY-ENTRY FILES MUST BE INCLUDED: ddd###.TWF AND
C     ddd###.IDX AND ALONG WITH THE SETUP.DAT FILE WHICH USE TO DETERMINE THE
C     SOURCE KEY-ENTRY FORM.  THESE FILES HAVE TO BE IN THE SAME DRIVE OR 
C     DIRECTORY.  IF THE PROGRAM HAS ENCOUNTERED A DUPLICATE ID IN BOTH SOURCE
C     AND TARGET KEY-ENTRY FILES, THE PROGRAM WILL ASK USER TO SELECT:
C
C           - OVERWRITE:  THE PROGRAM WILL OVERWRITE THE EXISTING RECORD IN
C                         THE TARGET KEY-ENTRY FILE.
C
C           - SKIP:       THE PROGRAM SKIPS THIS SOURCE RECORD ID AND CONTINUE
C                         THE PROCESS.
C
C           - STOP:       THE PROGRAM STOPS THE ENTIRE MERGE PROCESS AT THE
C                         POINT WHERE IT FOUND A RECORD ID IN THE SOURCE
C                         KEY-ENTRY FILE THAT WAS THE SAME AS IN THE TARGET
C                         KEY-ENTRY FILE.
C
C            NOTE:   THE PROGRAM ALREADY MERGED A PARTIAL OF THE SOURCE
C                    KEY-ENTRY FILE AND STOPPED AT WHERE IT FOUND A DUPLICATE 
C                    RECORD ID.
C
*******************************************************************************
C
C       **  DEFINE THE INTERFACE TO THE C ROUTINE "SYSTEM"
C
      INTERFACE TO INTEGER*2 FUNCTION SYSTEM [C]
     +        (STRING[REFERENCE])
      CHARACTER*1 STRING
      END
C      
      PROGRAM MRGTWF
C      
      CHARACTER*80 MSG
      CHARACTER*64 FILNAME,CHKFILE
      LOGICAL      FILEFLAG
C
C     *** DISPLAY MESSAGES IF THE PROGRAM RUN OUTSIDE THE CLICOM SYSTEM
C
      CHKFILE='P:\DATA\MESSAGES.FTN'
      INQUIRE(FILE=CHKFILE,EXIST=FILEFLAG)
      IF (.NOT.FILEFLAG) THEN
         CALL CLS
         CALL BEEP
         CALL LOCATE(16,0,IERR)
         CALL POSLIN(IR,IC)
         MSG = '           This program must run within CLICOM by'
     +          //' choosing choice #7'
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = '           (Enter a single DOS command) from the'
     +        //' CLICOM Introductory'  
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = '           menu.  Type: MRGTWF   press [Enter].'
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = ' '  
         IR = IR + 2
         CALL SCRNMSGI(MSG,IR,14)
         STOP ' '
      END IF            
C
C       ** DEFINE THE HELP FILE
C
      FILNAME = 'P:\HELP\MRGTWF.HLP'
C
C     ** GET ACTION FROM MENU:  
C        0. EXIT  1. MERGE TWO KEY-ENTRY FILES  2. LIST KEY-ENTRY RECORD ID'S
C                 3. VIEW A KEY-ENTRY FORM      4. LIST CURRENT KEY-ENTRY FORMS
C
  50  CONTINUE
      CALL CLS
      CALL LOCATE(3,1,IERR)
      CALL GETMNU('LIST/MRG-TWF',FILNAME,ICHOICE)
      IF (ICHOICE.EQ.0) THEN
         GO TO 100
      ELSE IF (ICHOICE.EQ.1) THEN   
         CALL READMRG
      ELSE IF (ICHOICE.EQ.2) THEN
         CALL PRNLSTWF
      ELSE IF (ICHOICE.EQ.3) THEN
         CALL VIEWKE
      ELSE
         CALL LISTKE
      END IF
C
      GO TO 50
C
 100  CONTINUE      
      CALL CLRMSG(1)
      CALL LOCATE(24,0,IERR)
      STOP ' '
      END         

*******************************************************************************
$PAGE
      SUBROUTINE READMRG
C
C     SUBROUTINE TO READ SOURCE AND TARGET KEY ENTRY FILES AND MAKE SURE BOTH 
C     KEY ENTRY FILES HAVE THE SAME FORMAT BEFORE THE MERGING STARTS.  THE
C     PROGRAM WILL SAVE THE TARGET KEY ENTRY FILE BEFORE IT MERGES. 
C
$INCLUDE: 'VAL1.INC'
C
      CHARACTER*1  RTNCODE,DELMARK,CODEFLG
      CHARACTER*2  RTNFLAG,HOURLBL(24)
      CHARACTER*3  DATASET,INTYPE,INDDS,RECTYPE
      CHARACTER*8  OUTCNT
      CHARACTER*8  INSTN
      CHARACTER*13 INKEY
      CHARACTER*20 RECPRT(2)
      CHARACTER*21 IDKEY
      CHARACTER*22 FILNAM,IDXNAM
      CHARACTER*40 IDXSRC,TWFSRC,SAVENAME,SETUPFIL,SRCFILE(5)
      CHARACTER*40 IDXNCHK,INFILE
      CHARACTER*78 MSGTXT
      INTEGER*2    SRECNUM,SDELKEY,SBGNIDX,SNUMIDX,SYSTEM,SRCNELEM
      INTEGER*2    TDSETID,SDSETID,ITYPE,STBLELEM(MAXELEM),SRCLNGTH
C
      PARAMETER    (NTYPD=7)
      CHARACTER*3  TBLRECTYP(NTYPD)
      INTEGER*2    TBLNUMLIN(NTYPD)
      DATA TBLRECTYP  /'MLY','10D','DLY','SYN','HLY','15M','U-A'/
     +    ,TBLNUMLIN /12,36,31,8,24,96,100/
C
C       ** GET THE DATA TYPE
C
      CALL LOCATE(3,45,IERR)
      CALL GETMNU('DR-DATATYPES',' ',ITYPE)
      IF (ITYPE.EQ.0)THEN
         RETURN         
      END IF
C
C       ** INITIALIZE FIELDS AND SET THE DATASET-ID
C
      CALL CLS
      SRCFILE(1) = ' '
      SRCFILE(2)(1:3) = TBLRECTYP(ITYPE)
      SRCFILE(3) = ' '
      SRCFILE(4)(1:3) = TBLRECTYP(ITYPE)
      SRCFILE(5) = ' '
  110 CONTINUE
      INFILE = ' '
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
      RTNFLAG = 'FA'
      CALL LOCATE(3,0,IERR)
      CALL GETLFRM('MRGTWFIO','  ',SRCFILE,40,RTNFLAG)
      IF (RTNFLAG.EQ.'4F') GO TO 280
C
C       ** RETRIEVE THE FIELDS FROM THE USER
C
      IF (SRCFILE(3).EQ.' '.OR.SRCFILE(5).EQ.' ') THEN
         CALL WRTMSG(4,101,12,1,1,' ',0)
         GO TO 110
      END IF
      READ(SRCFILE(3),'(I3)') SDSETID
      READ(SRCFILE(5),'(I3)') TDSETID
      RECTYPE = TBLRECTYP(ITYPE)
C
C       ** DEFINED THE NUMBER LINE FOR CURRENT DATA TYPE
C
      NUMLINE = TBLNUMLIN(ITYPE)
C
C       ** CALCULATE THE RECORD LENGTH FOR THE SOURCE SETUP.DAT FILE
C
      IRECLEN = 18 + 2*MAXELEM + 5*2
C
C       ** OPEN THE SETUP.DAT FILE TO GET INFOMATION OF SOURCE KEY-ENTRY FORM
C
      LGTH = LNG(SRCFILE(1))
      IF (SRCFILE(1)(LGTH:LGTH).NE.'\') THEN
         INFILE = SRCFILE(1)(1:LGTH)//'\'
      ELSE
         INFILE = SRCFILE(1)(1:LGTH)
      END IF
      LGTH = LNG(INFILE)
      SETUPFIL = INFILE(1:LGTH)//'SETUP.DAT'
C
      OPEN (5,FILE=SETUPFIL,STATUS='OLD',ACCESS='DIRECT'
     +      ,RECL=IRECLEN,SHARE='DENYWR',MODE='READ',IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') SETUPFIL,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 110
      END IF
C
C       ** SEARCH FOR THE DATATYPE AND DATASET-ID SPECIFIED - REMEMBER 
C          THERE ARE 10 SLOTS ALLOWED FOR EACH DATATYPE SO BEGIN THE 
C          SEARCH WHERE APPROPRIATE
C
      WRITE(DATASET,'(I3.3)') SDSETID
      IF (ITYPE.EQ.2) THEN
         JTYPE = 6
      ELSE IF (ITYPE.EQ.6) THEN
         JTYPE = 7
      ELSE IF (ITYPE.EQ.7) THEN
         JTYPE = 5  
      ELSE IF (ITYPE.GT.2) THEN
         JTYPE = ITYPE - 1
      ELSE 
         JTYPE = 1
      END IF
      ISTRT = (JTYPE-1)*10 + 1
      DO 140 IREC = ISTRT,999
         READ(5,REC=IREC,ERR=145) DELMARK,INTYPE,INDDS,SRCNELEM
     +         ,HIGHPCT,LOWPCT
     +         ,(STBLELEM(I1),I1=1,MAXELEM),(AQCELEM(I2),I2=1,5)
         IF (DELMARK.EQ.' '.AND.INTYPE.EQ.RECTYPE.AND.
     +           INDDS.EQ.DATASET) THEN
             GO TO 150
         END IF
  140 CONTINUE
C
C       ** IF DATASET NOT FOUND - PRINT ERROR MESSAGE
C
  145 CONTINUE
      CALL WRTMSG(4,64,12,1,1,' ',0)
      CLOSE(5)
      GO TO 110
  150 CONTINUE
      CLOSE(5)
C
C       ** OPEN THE SETUP.DAT FILE TO GET INFOMATION OF TARGET KEY-ENTRY FORM
C
      CALL GETSET(TDSETID,ITYPE,RECTYPE,HOURLBL,RTNCODE)
      IF (RTNCODE.NE.'0') THEN
         GO TO 110
      END IF
C
C      ** COMPARE THE SOURCE AND TARGET KEY-ENTRY FORMS TO MAKE SURE THEY ARE
C         IDENTICAL IN NUMBER OF ELEMENTS, ORDER OF ELEMENT CODES IN THE BOTH
C         FORMS BEFORE THE MERGING PROCESS.  OTHERWISE, THE PROGRAM STOPS AT
C         THIS POINT.
C
      IF (NUMELEM.EQ.SRCNELEM) THEN
         GO TO 160
      ELSE
         WRITE(MSGTXT,'(I2,'' --'',I2)') SRCNELEM,NUMELEM
         CALL WRTMSG(4,431,12,1,1,MSGTXT,7)
         RETURN
      END IF
 160  CONTINUE
      DO 170 I=1,MAXELEM
         IF (STBLELEM(I).EQ.TBLELEM(I)) THEN
            GO TO 170
         ELSE     
            CALL WRTMSG(4,432,12,1,1,' ',0)
            RETURN
         END IF
 170  CONTINUE
C
C       ** OPEN THE SOURCE .IDX AND .TWF FILES      
C
      WRITE(IDXSRC,'(A,A3,I3.3,A4)')INFILE(1:LGTH),RECTYPE,SDSETID
     +      ,'.IDX'
      OPEN (69,FILE=IDXSRC,STATUS='OLD',ACCESS='DIRECT',
     +         MODE='READ',FORM='UNFORMATTED',RECL=25,IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') IDXSRC,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 280            
      END IF   
C
C       ** CALCULATE THE RECORD LENGTH FOR THE SOURCE .TWF FILE
C
      SRCLNGTH = (SRCNELEM * NUMLINE * 8) + 21
C
      WRITE(TWFSRC,'(A,A3,I3.3,A4)')INFILE(1:LGTH),RECTYPE,SDSETID
     +      ,'.TWF'
      OPEN (70,FILE=TWFSRC,STATUS='OLD',ACCESS='DIRECT',
     +      MODE='READ',FORM='UNFORMATTED',RECL=SRCLNGTH,IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') TWFSRC,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 280            
      END IF  
C
C       ** SAVE THE TARGET ddd###.IDX AND ddd###.TWF FILES UNDER THE FILE NAMES
C          ddd###.MTF AND ddd###.MTX  BEFORE THE PROGRAM STARTS TO MERGE
C
      IDXNCHK = 'C:\CLICOM\DATA\'
      IDXNAM  = 'P:\DATA\'
      WRITE(IDXNAM(9:),'(A3,I3.3,A4)') RECTYPE,TDSETID,'.IDX'
      WRITE(IDXNCHK(16:),'(A3,I3.3,A4)') RECTYPE,TDSETID,'.IDX'
C
C     *** NOT ALLOW TO MERGE THE SAME KEY-ENTRY IN CLICOM SYSTEM
C
      IF (IDXSRC.EQ.IDXNAM.OR.IDXSRC.EQ.IDXNCHK) THEN
         WRITE(MSGTXT,'(A3,I3.3,A4)') RECTYPE,TDSETID,'.TWF'
         CALL WRTMSG(4,430,12,1,1,MSGTXT,10)
         GO TO 280
      END IF

      FILNAM = IDXNAM(1:14)// '.TWF'
C      
      SAVENAME = IDXNAM(1:14)//'.MTX'
      WRITE(MSGTXT,180)IDXNAM,SAVENAME
  180 FORMAT('COPY ',A,1X,A,' >>NUL')
      LGTH = LNG(MSGTXT)+1
      MSGTXT(LGTH:LGTH) = CHAR(0)    
      I = SYSTEM(MSGTXT)
C      
      SAVENAME = FILNAM(1:14)//'.MTF'
      MSGTXT = ' '      
      WRITE(MSGTXT,180)IDXNAM,SAVENAME
      LGTH = LNG(MSGTXT)+1
      MSGTXT(LGTH:LGTH) = CHAR(0)    
      I = SYSTEM(MSGTXT)
C
C       ** OPEN THE TARGET FILES -- UNIT 19 = .IDX       UNIT 20 = .TWF
C
      CALL OPENFILES(2)
C
C     INITIALIZE THE WORK ARRAYS
C
      DO 190 J=1,NUMLINE
         DO 190 K=1,NUMELEM
         VALARRAY(K,J) = ' '
         FLAGARRAY(K,J,1) = ' '
         FLAGARRAY(K,J,2) = ' '
 190   CONTINUE
C
C       ** READ THE FIRST RECORD OF THE SOURCE .IDX FILE
C
      READ(69,REC=1) SDELKEY,SBGNIDX,SNUMIDX
      IF (SNUMIDX.EQ.1.OR.SBGNIDX.GT.SNUMIDX) THEN
         CALL WRTMSG(3,300,12,1,1,' ',0)
         GO TO 280            
      END IF
C      
C       ** WRITE THE MESSAGE LINE FOR THE NUMBER OF RECORDS THAT ARE
C          READ, WRITTEN
C 
      MSGTXT = ' '
      CALL GETMSG(561,MSGTXT)
      CALL GETMSG(999,MSGTXT)
      CALL PARSE1(MSGTXT,78,2,20,RECPRT,RTNCODE)
      NCPRT1=LNG(RECPRT(1))+2
      MSGTXT = ' '
      MSGTXT(2:)=RECPRT(1)
      MSGTXT(NCPRT1+10:)=RECPRT(2)
      NCPRT2=LNG(MSGTXT)+1
      CALL CLRMSG(3)
      CALL LOCATE(22,0,IERR)
      CALL WRTSTR(MSGTXT,NCPRT2,14,0)
C
C       ** MAIN LOOP - READ THE SOURCE .TWF FILE AND MERGE INTO THE TARGET
C          .TWF FILE
C
      KNTRD  = 0
      KNTWT  = 0
      DO 250 I = SBGNIDX,SNUMIDX
         READ(69,REC=I) SDELKEY,INSTN,INKEY,SRECNUM
         IF (SDELKEY.LT.2.) THEN
             GO TO 250
         END IF
         KNTRD = KNTRD+1
         READ(70,REC=SRECNUM) IDKEY,((VALARRAY(I1,J1)
     +      ,I1=1,NUMELEM),J1=1,NUMLINE),(((FLAGARRAY(K,L,M)
     +      ,M=1,2),K=1,NUMELEM),L=1,NUMLINE)
C
C       ** WRITE NUMBER OF RECORDS READ AND WRITE TO SCREEN            
C
         WRITE(OUTCNT,210) KNTRD
         CALL LOCATE(22,NCPRT1,IERR)         
         OUTCNT(8:8) = CHAR(0)
         CALL CWRITE(OUTCNT,12,IERR)
         WRITE(OUTCNT,210) KNTWT
         CALL LOCATE(22,NCPRT2,IERR)         
         OUTCNT(8:8) = CHAR(0)
         CALL CWRITE(OUTCNT,12,IERR)
  210    FORMAT(I7,1X)       
C
C       ** REPLACE THE SOURCE DATASET-ID WITH THE TARGET DATASET-ID TO MAKE
C          THE TARGET KEY-ENTRY FILE HAS A UNIQUE DATASET-ID
C
         WRITE(IDKEY(9:11),'(I3.3)') TDSETID
C
C       ** START TO MERGE KEY ENTRY FILES
C
         CALL MRGREC(RECTYPE,IDKEY,KNTWT,CODEFLG)
C
C       ** WRITE NUMBER OF RECORDS WRITTEN TO SCREEN
C
         WRITE(OUTCNT,210) KNTWT
         CALL LOCATE(22,NCPRT2,IERR)         
         OUTCNT(8:8) = CHAR(0)
         CALL CWRITE(OUTCNT,12,IERR)
         IF (CODEFLG.NE.'0') GO TO 280
C
C        **  RE-INITIALIZE THE WORK ARRAYS TO HOLD THE NEW DATA. 
C
         DO 220 J=1,NUMLINE
            DO 220 K=1,NUMELEM
            VALARRAY(K,J) = ' '
            FLAGARRAY(K,J,1) = ' '
            FLAGARRAY(K,J,2) = ' '
  220     CONTINUE
C
  250 CONTINUE
  280 CONTINUE
C
C       ** CLOSE FILES
C
      CLOSE(69)
      CLOSE(70)
      CLOSE(19)
      CLOSE(20)
C      
      RETURN
      END
*******************************************************************************
$PAGE
      SUBROUTINE MRGREC(RECTYPE,IDKEY,KNTWT,ERRFLG)
C
C     ROUTINE USES TO MERGE THE KEY ENTRY FILES.  IF THE KEY ENTRY FILE HAS A
C     DUPLICATE RECORD AND IT WAITS FOR THE USER ACTIONS:OVERWRITE, SKIP, OR 
C     STOP THE PROCESS.
C
      CHARACTER*1  RTNCODE,ERRFLG
      CHARACTER*2  RTNFLAG
      CHARACTER*3  RECTYPE
      CHARACTER*13 CHOICE(4)
      CHARACTER*21 IDKEY
      LOGICAL WRTDATA
C
      WRTDATA = .TRUE.
      CHOICE(4) = ' '
      ERRFLG  = '0'
C
C       ** DO A BINARY SEARCH ON THE INDEX FILE TO CHECK FOR ANY EXISTING
C          RECORDS BEFORE THE MERGING STARTS
C
      CALL BINDATA(IDKEY,RTNCODE)
C
C          ** IF RTNCODE = 2 THEN ID NOT FOUND SO IT'S NEW (OK).
C             IF RTNCODE = 0 THEN THE PROGRAM HAS ENCOUNTERED A DUPLICATE ID
C             ASK THE USER TO CONTINUE OR QUIT.  ANY OTHER RTNCODE INDICATES
C             AN ERROR.
C
      IF (RTNCODE .NE.'2') THEN
         IF (RTNCODE .EQ. '0') THEN
            CHOICE(1) = IDKEY(1:8)
            CHOICE(2) = IDKEY(9:11)
C
C       ** DISPLAY THE INFORMATION OF A DUPLICATE RECORD
C
            IF (RECTYPE.EQ.'DLY') THEN
               WRITE(CHOICE(3),400)IDKEY(12:15),IDKEY(16:17)
            ELSE IF (RECTYPE.EQ.'MLY'.OR.RECTYPE.EQ.'10D') THEN
               WRITE(CHOICE(3),400)IDKEY(12:15)
            ELSE IF (RECTYPE.EQ.'HLY'.OR.RECTYPE.EQ.'SYN'.OR.RECTYPE
     +         .EQ.'15M') THEN
                WRITE(CHOICE(3),400)IDKEY(12:15),IDKEY(16:17)
     +               ,IDKEY(18:19)
            ELSE IF (RECTYPE.EQ.'U-A') THEN
                WRITE(CHOICE(3),400)IDKEY(12:15),IDKEY(16:17)
     +               ,IDKEY(18:19),IDKEY(20:21)
            END IF
 400        FORMAT(A4,:,'-',A2,:,'-',A2,:,'-',A2)
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
            RTNFLAG = 'FA'
            CALL LOCATE(3,0,IERR)
            CALL GETLFRM('MRGDUPID ',' ',CHOICE,13,RTNFLAG)
            IF (RTNFLAG.EQ.'4F') THEN
               ERRFLG = '1'
            END IF
            READ(CHOICE(4),'(I1)') ICHOICE           
C
C       ** ASKS USER FOR VERIFICATION:
C                                     1=OVERWRITE   2=SKIP RECORD   3=STOP
C
            IF (ICHOICE.EQ.2) THEN
               WRTDATA = .FALSE.
            ELSE IF (ICHOICE.EQ.3) THEN
               WRTDATA = .FALSE.
               ERRFLG = '1'               
            END IF                        
         ELSE
            CALL WRTMSG(5,51,12,1,1,RTNCODE,1)
            WRTDATA = .FALSE.
         END IF
      END IF
      IF (WRTDATA) THEN
         CALL PUTDATA(IDKEY,2,RTNFLG)
         KNTWT = KNTWT + 1
      END IF   
C      
      RETURN
      END
*******************************************************************************
$PAGE
      SUBROUTINE PRNLSTWF
C
C     ROUTINE USES TO LIST THE RECORD ID'S IN A KEY ENTRY FILE TO SCREEN
C     OR PRINTER.
C  
$INCLUDE: 'VAL1.INC'
C
      CHARACTER*1  DELMARK
      CHARACTER*2  RTNFLAG
      CHARACTER*3  DATASET,INTYPE,INDDS,RECTYPE
      CHARACTER*8  INSTN,DDSETID
      CHARACTER*13 INKEY
      CHARACTER*10 DBLINES
      CHARACTER*40 SETUPFIL,FIELDS(3),IDXNAME,TWFNAME,INFILE,PRMFILE
      CHARACTER*78 MSGTXT,TLTXT(7)
      INTEGER*2    DSETID,ITYPE,LINENUM,RECNUM,DELKEY,BGNIDX,NUMIDX
C
      CHARACTER*3 TBLRECTYP(7)
      DATA TBLRECTYP  /'MLY','10D','DLY','SYN','HLY','15M','U-A'/
      DATA DBLINES /'ÍÍÍÍÍÍÍÍÍÍ'/
C
      IDXNAME  = ' '
      TWFNAME  = ' '
      PRMFILE = 'P:\DATA\PRINTWF.PRM'
C
C       ** INITIALIZE AND SET THE DATA TYPE
C
      CALL LOCATE(3,45,IERR)
      CALL GETMNU('DR-DATATYPES',' ',ITYPE)
      IF (ITYPE.EQ.0)THEN
         RETURN         
      END IF
      CALL CLS
      FIELDS(1) = ' '
      FIELDS(2) = TBLRECTYP(ITYPE)
      FIELDS(3) = ' '
 300  CONTINUE
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
      RTNFLAG = 'FA'
      CALL LOCATE(3,0,IERR)
      CALL GETLFRM('PRNLSTWF',' ',FIELDS,40,RTNFLAG)
      IF (RTNFLAG.EQ.'4F') GO TO 610
C
C       ** MAKE SURE ALL FIELDS HAVE BEEN ENTERED
C
      DO 320 I=1,3
         IF (FIELDS(I).EQ.' ') THEN
            CALL BEEP
            GO TO 300
         END IF
 320  CONTINUE         
C
C       ** RETRIEVE THE FIELDS FROM THE USER
C
      INFILE = ' '    
      LGTH = LNG(FIELDS(1))
      IF (FIELDS(1)(LGTH:LGTH).NE.'\') THEN
          INFILE = FIELDS(1)(1:LGTH)//'\'
      ELSE
          INFILE = FIELDS(1)(1:LGTH)
      END IF
      LGTH = LNG(INFILE)
      SETUPFIL=INFILE(1:LGTH)//'SETUP.DAT'
      RECTYPE = FIELDS(2)
      READ(FIELDS(3),'(I3)') DSETID
C
C       ** CALCULATE THE RECORD LENGTH FOR THE SETUP.DAT FILE
C
      IRECLEN = 18 + 2*MAXELEM + 5*2
C
C       ** OPEN THE SETUP.DAT FILE TO GET INFORMATION OF THE KEY-ENTRY FORM
C
      OPEN (5,FILE=SETUPFIL,STATUS='OLD',ACCESS='DIRECT'
     +      ,RECL=IRECLEN,SHARE='DENYWR',MODE='READ',IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') SETUPFIL,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 300
      END IF
      WRITE(DATASET,'(I3.3)') DSETID
      IF (ITYPE.EQ.2) THEN
         JTYPE = 6
      ELSE IF (ITYPE.EQ.6) THEN
         JTYPE = 7
      ELSE IF (ITYPE.EQ.7) THEN
         JTYPE = 5  
      ELSE IF (ITYPE.GT.2) THEN
         JTYPE = ITYPE - 1
      ELSE 
         JTYPE = 1
      END IF
      ISTRT = (JTYPE-1)*10 + 1
      DO 350 IREC = ISTRT,999
         READ(5,REC=IREC,ERR=355) DELMARK,INTYPE,INDDS,NUMELEM
     +         ,HIGHPCT,LOWPCT
     +         ,(TBLELEM(I1),I1=1,MAXELEM),(AQCELEM(I2),I2=1,5)
         IF (DELMARK.EQ.' '.AND.INTYPE.EQ.RECTYPE.AND.
     +           INDDS.EQ.DATASET) THEN
             GO TO 360
         END IF
  350 CONTINUE
C
C       ** IF DATASET NOT FOUND - PRINT ERROR MESSAGE AND RETURN
C
  355 CONTINUE
         CALL WRTMSG(4,64,12,1,1,' ',0)
         CLOSE(5)
         GO TO 300
  360 CONTINUE
      CLOSE(5)
C
C       ** OPEN THE .IDX FILES -- UNIT 69 = .IDX
C
      WRITE(IDXNAME,'(A,A3,I3.3,A4)')INFILE(1:LGTH),RECTYPE,DSETID,
     +      '.IDX'
C
      OPEN (69,FILE=IDXNAME,STATUS='OLD',ACCESS='DIRECT',MODE='READ',
     +         FORM='UNFORMATTED',RECL=25,IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') IDXNAME,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 610
      END IF   
C
C       ** OPEN THE PRINTWF PARAMETER FILE
C
 380  CONTINUE
      OPEN (61,FILE=PRMFILE,STATUS='OLD',FORM='FORMATTED'
     +    ,IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG('P:\DATA\PRINTWF.PRM     ','MRGTWF       ',IOCHK)
         GO TO 380 
      END IF   
      READ(61,*,ERR=600)(TLTXT(I),I=1,7)  
      READ(61,*,ERR=600)LINENUM
      CLOSE(61)
C
C        ** SELECT A OPTION TO LIST OR PRINT THE CONTENT OF THE KEY ENTRY FILE
C
      CALL LOCATE(14,20,IERR)
      CALL GETMNU('KE-OUTPUT   ',' ',ICHOICE)
      IF (ICHOICE.EQ.0) THEN
         GO TO 300
      ELSE IF (ICHOICE.EQ.2) THEN   
C
C       ** OPEN THE PRINTER OUTPUT IF USER WANTS TO PRINT THE CONTENT OF
C          KEY ENTRY FILE
C
          CALL LOCATE(23,0,IERR)
          CALL WRTSTR(' Printing... ',13,12,0)
          OPEN (50,FILE='PRN',STATUS='UNKNOWN',FORM='FORMATTED')
          CALL PRINTWF(RECTYPE,INDDS,TLTXT,LINENUM)
          CLOSE (50)
          GO TO 610
      END IF
C
C       ** READ THE FIRST RECORD OF THE .IDX FILE
C
      READ(69,REC=1) DELKEY,BGNIDX,NUMIDX
      IF (NUMIDX.EQ.1.OR.BGNIDX.GT.NUMIDX) THEN
         CALL WRTMSG(3,300,12,1,1,' ',0)
         GO TO 610            
      END IF
C
C       ** WRITE THE FUNCTION KEY DEFINITIONS
C
      CALL CLS
      CALL LOCATE(24,0,IERR)
      CALL GETDEASE(DEVER)
      IF (DEVER.EQ.'4.0') THEN
          CALL WRTSTR(' ESC',4,14,0)
      ELSE
          CALL WRTSTR(' F4',3,14,0)
      END IF
      CALL WRTSTR('Quit',4,15,4)
      CALL WRTSTR('  PgDn',6,14,0)
      CALL WRTSTR('Next page',9,15,4)
      CALL WRTSTR('  PgUp',6,14,0)
      CALL WRTSTR('Prev page',9,15,4)
C
C       ** WRITE HEADERS AND DATASET-ID
C
      NUMFLD = 2
      CALL LOCATE(0,20,IERR)
      CALL WRTSTR(TLTXT(1),78,14,0)
      CALL LOCATE(2,29,IERR)
      CALL WRTSTR(TLTXT(3),11,14,0)
      CALL LOCATE(2,42,IERR)
      DDSETID = RECTYPE//INDDS
      CALL WRTSTR(DDSETID,6,15,1)
C
C       ** DETERMINE FIELDS (MONTH,DAY,HOUR) FOR CURRENT DATA TYPE
C
      CALL LOCATE(4,7,IERR)
      CALL WRTSTR(TLTXT(2),10,14,0)
      CALL LOCATE(4,27,IERR)
      CALL WRTSTR(TLTXT(4),4,14,0)
      IF (ITYPE.GE.3) THEN
         CALL LOCATE(4,41,IERR)
         CALL WRTSTR(TLTXT(5),5,14,0)
         NUMFLD = 3
      END IF
      IF (ITYPE.GE.4) THEN
         CALL LOCATE(4,56,IERR)
         CALL WRTSTR(TLTXT(6),3,14,0)
         NUMFLD = 4
      END IF
      IF (ITYPE.EQ.7) THEN
         CALL LOCATE(4,69,IERR)
         CALL WRTSTR(TLTXT(7),4,14,0)
         NUMFLD = 5
      END IF
      CALL LOCATE(5,5,IERR)
      WRITE(*,410) (DBLINES,J=1,NUMFLD)
 410  FORMAT(3X,A10,10X,A4,10X,:,A5,10X,:,A3,10X,:,A4)
C
C       ** MAIN LOOP - READ .TWF FILE
C
      MXLINE  = 15
      IDXHLD  = 0
      IROW    = 6
      NUMHLD  = 0
      NUMPAGE = INT(NUMIDX/MXLINE)
      IF (MOD(NUMIDX,MXLINE).NE.0) THEN
         NUMPAGE = NUMPAGE + 1
      END IF
      ISTRIDX  = BGNIDX
      IENDIDX  = NUMIDX
      IF (NUMPAGE.GE.2) THEN
         IENDIDX  = BGNIDX + MXLINE  - 1
      END IF
  430 CONTINUE
C
C       ** START TO DISPLAY THE SCREEN OF RECORDS.  THE PROGRAM WILL DISPLAY
C          15 RECORD ID'S PER SCREEN
C
      DO 440 I = ISTRIDX,IENDIDX
         READ(69,REC=I) DELKEY,INSTN,INKEY,RECNUM
         IF (DELKEY.LT.2.) THEN
            CALL WRTMSG(3,300,12,1,1,' ',0)
            GO TO 610
         END IF
         CALL LOCATE(IROW,8,IERR)
         CALL WRTSTR(INSTN,8,15,1)
         CALL LOCATE(IROW,27,IERR)
         CALL WRTSTR(INKEY(4:7),4,15,1)
         IF (NUMFLD.GE.3) THEN
             CALL LOCATE(IROW,43,IERR)
             CALL WRTSTR(INKEY(8:9),2,15,1)
         END IF
         IF (NUMFLD.GE.4) THEN
             CALL LOCATE(IROW,57,IERR)
             CALL WRTSTR(INKEY(10:11),2,15,1)
         END IF
         IF (NUMFLD.EQ.5) THEN
             CALL LOCATE(IROW,70,IERR)
             CALL WRTSTR(INKEY(12:13),2,15,1)
         END IF
         IROW  = IROW + 1
  440 CONTINUE
C
  450 CONTINUE
C
C       ** CHECK FOR FUNCTION KEYS AND TAKE THE APPROPRIATE ACTION
C
      CALL GETCHAR(0,INCHAR)
      CALL CLRMSG(3)
      IF (INCHAR.EQ.'DP'.OR.INCHAR.EQ.'DA') THEN
         IF (IENDIDX.EQ.NUMIDX) THEN
            CALL WRTMSG(3,062,12,1,0,' ',0)
            GO TO 450
         ELSE 
            ISTRIDX = IENDIDX + 1
            IENDIDX = IENDIDX + MXLINE
            IF (IENDIDX.GT.NUMIDX) THEN
               IENDIDX = NUMIDX
            END IF
         END IF
      ELSE IF (INCHAR.EQ.'UP'.OR.INCHAR.EQ.'UA') THEN
         IF (ISTRIDX.EQ.BGNIDX.OR.NUMHLD.LE.0) THEN
            CALL BEEP
            GO TO 450
         ELSE IF (IENDIDX.GE.NUMHLD) THEN
            IF (IENDIDX.EQ.NUMIDX) THEN
               ISTRIDX = ISTRIDX - MXLINE
               IENDIDX = ISTRIDX + MXLINE - 1
            ELSE
               ISTRIDX = ISTRIDX - MXLINE
               IENDIDX = IENDIDX - MXLINE
            END IF
            IF (ISTRIDX.LT.BGNIDX) THEN
               ISTRIDX = BGNIDX
            END IF
         END IF
      ELSE IF (INCHAR.EQ.'HO') THEN
         IF (ISTRIDX.EQ.BGNIDX) THEN
            CALL BEEP
            GO TO 450
         END IF
         ISTRIDX  = BGNIDX
         IENDIDX  = NUMIDX
         IF (NUMPAGE.GE.2) THEN
           IENDIDX  = BGNIDX + MXLINE  - 1
         END IF
      ELSE IF (INCHAR.EQ.'EN') THEN
         IF (IENDIDX.EQ.NUMIDX) THEN
            CALL BEEP
            GO TO 450
         END IF
         LINE = MXLINE
         IF (MOD(NUMIDX,MXLINE).NE.0) THEN
            LINE = MOD(NUMIDX,MXLINE) - 1
         END IF
         ISTRIDX  = NUMIDX - LINE + 1
         IENDIDX  = NUMIDX
      ELSE IF (INCHAR.EQ.'4F'.OR.INCHAR.EQ.'ES') THEN
         GO TO 610
      ELSE
         GO TO 450
      END IF
      IROW = 6
      IDXHLD = ISTRIDX
      NUMHLD = IENDIDX
C
C       ** CLEAR THE VALUE AREA OF THE SCREEN BY SCROLLING UP THE ENTIRE WINDOW
C
      CALL CLTEXT(0,0,IERR)
      CALL SCROLL(1,16,IROW,0,15+IROW,79)
      GO TO 430
C
C      ** ERROR READING PARAMETER FILE (P:\DATA\PRINTWF.PRM)
C
 600  CONTINUE
      LGTH = LNG(PRMFILE)
      CALL WRTMSG(3,191,12,1,1,PRMFILE,LGTH)
      CLOSE(61)
 610  CONTINUE
C
C       ** CLOSE FILES
C
      CLOSE(69)
      RETURN
      END
*******************************************************************************
$PAGE
      SUBROUTINE PRINTWF(RECTYPE,INDDS,TLTXT,LINENUM)
C
C    ROUTINE PRINTS THE RECORD ID'S IN A KEY ENTRY FILE
C
      CHARACTER*3  RECTYPE,INDDS
      CHARACTER*8  INSTN
      CHARACTER*14 DBLINES,SLINES
      CHARACTER*13 INKEY
      CHARACTER*78 TLTXT(7)
      INTEGER*2    LINENUM,DELKEY,BGNIDX,NUMIDX,RECNUM
      DATA SLINES  /'ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ'/
      DATA DBLINES /'ÍÍÍÍÍÍÍÍÍÍÍÍÍÍ'/
C
      LINE    = 12
      NPAGE   = 1
C
C      ** DETERMINE FIELDS(MONTH,DAY,HOUR) FOR CURRENT DATA TYPE
C
      IF (RECTYPE.EQ.'MLY'.OR.RECTYPE.EQ.'10D') THEN
          TLTXT(5) = ' '
          TLTXT(6) = ' '
          TLTXT(7) = ' '
          NUMFLD = 2
      ELSE IF (RECTYPE.EQ.'DLY') THEN
          TLTXT(6) = ' '
          TLTXT(7) = ' '
          NUMFLD = 3
      ELSE IF (RECTYPE.EQ.'HLY'.OR.RECTYPE.EQ.'SYN'.OR.
     +         RECTYPE.EQ.'15M') THEN
          TLTXT(7) = ' '
          NUMFLD = 4
      ELSE IF (RECTYPE.EQ.'U-A') THEN
          NUMFLD = 5
      END IF
C
C       ** READ THE FIRST RECORD OF THE .IDX FILE
C
      READ(69,REC=1) DELKEY,BGNIDX,NUMIDX
      IF (NUMIDX.EQ.1.OR.BGNIDX.GT.NUMIDX) THEN
         CALL WRTMSG(3,300,12,1,1,' ',0)
         RETURN
      END IF
C
C       ** WRITE HEADERS
C
      WRITE(50,1025)'Page - ',NPAGE
      WRITE(50,1000)TLTXT(1)
      WRITE(50,1005)TLTXT(3),RECTYPE,INDDS
      WRITE(50,1040)(DBLINES,J=1,NUMFLD)
      WRITE(50,1010)TLTXT(2),(TLTXT(I),I=4,7)
      WRITE(50,1040)(SLINES,J=1,NUMFLD)
      DO 200 I = BGNIDX,NUMIDX
         LINE = LINE + 1
         READ(69,REC=I) DELKEY,INSTN,INKEY,RECNUM
         IF (DELKEY.LT.2.) THEN
             GO TO 200
         END IF
C
C       ** DETERMINE NUMBER OF LINES PER PAGE
C
         IF (LINE.GE.LINENUM) THEN
             WRITE(50,1040)(SLINES,J=1,NUMFLD)
             NPAGE = NPAGE + 1
             LINE = 14
             WRITE(50,1030)'Page - ',NPAGE
             WRITE(50,1000)TLTXT(1)
             WRITE(50,1005)TLTXT(3),RECTYPE,INDDS
             WRITE(50,1040)(DBLINES,J=1,NUMFLD)
             WRITE(50,1010)TLTXT(2),(TLTXT(K),K=4,7)
             WRITE(50,1040)(SLINES,J=1,NUMFLD)
         END IF
         WRITE(50,1020)INSTN,INKEY(4:7),INKEY(8:9),INKEY(10:11),
     +                 INKEY(12:13)
 200  CONTINUE
      WRITE(50,1040)(DBLINES,J=1,NUMFLD)
      RETURN
C
C       ** FORMAT STATEMENTS
C
 1000 FORMAT(22X,A,//)
 1005 FORMAT(32X,A11,1X,A3,A3,///)
 1010 FORMAT(7X,A10,10X,A4,10X,:,A5,10X,:,A3,10X,:,A4)
 1020 FORMAT(8X,A8,11X,A4,11X,:,A2,13X,:,A2,11X,:,A2)
 1025 FORMAT(71X,A7,I2,//)
 1030 FORMAT('1',71X,A7,I2,//)
 1040 FORMAT(5X,5(A14,:))
      END

*******************************************************************************
$PAGE
      SUBROUTINE VIEWKE
C
C     ROUTINE USES TO VIEW ALL ELEMENT CODES THAT DEFINED IN A KEY-ENTRY FORM
C
$INCLUDE: 'VAL1.INC'
C
      PARAMETER (MAX2ELEM = (MAXELEM * 2)+2)
      CHARACTER*1  DELMARK
      CHARACTER*2  RTNFLAG
      CHARACTER*3  DATASET,INTYPE,INDDS,RECTYPE,TBLRECTYP(7)
      CHARACTER*6  FIELD(MAX2ELEM)
      CHARACTER*40 SETUPFIL,FIELDS(3),INFILE
      CHARACTER*78 MSGTXT
      INTEGER*2    DSETID,ITYPE
      DATA TBLRECTYP  /'MLY','10D','DLY','SYN','HLY','15M','U-A'/
C
C       ** INITIALIZE AND SET THE DATA TYPE
C
      CALL LOCATE(3,45,IERR)
      CALL GETMNU('DR-DATATYPES',' ',ITYPE)
      IF (ITYPE.EQ.0)THEN
         RETURN         
      END IF
      CALL CLS
      FIELDS(1) = ' '
      FIELDS(2) = TBLRECTYP(ITYPE)
      FIELDS(3) = ' '
 100  CONTINUE
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
      RTNFLAG = 'FA'
      CALL LOCATE(3,0,IERR)
      CALL GETLFRM('PRNLSTWF',' ',FIELDS,40,RTNFLAG)
      IF (RTNFLAG.EQ.'4F') GO TO 160
C
C       ** MAKE SURE ALL FIELDS HAVE BEEN ENTERED
C
      DO 120 I=1,3
         IF (FIELDS(I).EQ.' ') THEN
            CALL BEEP
            GO TO 100
         END IF
 120  CONTINUE         
C
C       ** RETRIEVE THE FIELDS FROM THE USER
C
      INFILE = ' '    
      LGTH = LNG(FIELDS(1))
      IF (FIELDS(1)(LGTH:LGTH).NE.'\') THEN
          INFILE = FIELDS(1)(1:LGTH)//'\'
      ELSE
          INFILE = FIELDS(1)(1:LGTH)
      END IF
      LGTH = LNG(INFILE)
      SETUPFIL=INFILE(1:LGTH)//'SETUP.DAT'
      RECTYPE = FIELDS(2)
      READ(FIELDS(3),'(I3)') DSETID
C
C       ** CALCULATE THE RECORD LENGTH FOR THE SETUP.DAT FILE
C
      IRECLEN = 18 + 2*MAXELEM + 5*2
C
C       ** OPEN THE SETUP.DAT FILE TO GET INFORMATION OF THE KEY-ENTRY FORM
C
      OPEN (5,FILE=SETUPFIL,STATUS='OLD',ACCESS='DIRECT'
     +      ,RECL=IRECLEN,SHARE='DENYWR',MODE='READ',IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') SETUPFIL,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 100
      END IF
      WRITE(DATASET,'(I3.3)') DSETID
      IF (ITYPE.EQ.2) THEN
         JTYPE = 6
      ELSE IF (ITYPE.EQ.6) THEN
         JTYPE = 7
      ELSE IF (ITYPE.EQ.7) THEN
         JTYPE = 5  
      ELSE IF (ITYPE.GT.2) THEN
         JTYPE = ITYPE - 1
      ELSE 
         JTYPE = 1
      END IF
      ISTRT = (JTYPE-1)*10 + 1
      DO 130 IREC = ISTRT,999
         READ(5,REC=IREC,ERR=155) DELMARK,INTYPE,INDDS,NUMELEM
     +         ,HIGHPCT,LOWPCT
     +         ,(TBLELEM(I1),I1=1,MAXELEM),(AQCELEM(I2),I2=1,5)
         IF (DELMARK.EQ.' '.AND.INTYPE.EQ.RECTYPE.AND.
     +           INDDS.EQ.DATASET) THEN
             GO TO 135
         END IF
 130  CONTINUE
 135  CONTINUE
      FIELD(MAX2ELEM-1) = TBLRECTYP(ITYPE)
      FIELD(MAX2ELEM) = DATASET
      DO 140 I = 1,MAX2ELEM-2
         FIELD(I) = '    '
 140  CONTINUE
C
      DO 145 I = 1,NUMELEM
         I2 = (I-1)*2 + 1
         WRITE(FIELD(I2),'(I3.3)') TBLELEM(I)
 145  CONTINUE
      CALL CLS
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
      CALL LOCATE(3,1,IERR)
      RTNFLAG = 'FA'
      CALL GETLFRM('SETUPELM',' ',FIELD,6,RTNFLAG)
      IF (RTNFLAG.EQ.'4F'.OR.RTNFLAG.EQ.'2F') THEN
         GO TO 160
      END IF
C
C       ** IF DATASET NOT FOUND - PRINT ERROR MESSAGE AND RETURN
C
 155  CONTINUE
      CALL WRTMSG(4,64,12,1,1,' ',0)
      CLOSE(5)
      GO TO 100
C
 160  CONTINUE
      CLOSE(5)
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE LISTKE
C
C     ROUTINE USES TO LIST CURRENT KEY-ENTRY FORMS WHICH DEFINED IN CLICOM
C
      CHARACTER*1  DELMARK
      CHARACTER*2  RTNFLAG
      CHARACTER*3  INTYPE,INDDS
      CHARACTER*8  BLANK
      CHARACTER*22 FIELDS
      CHARACTER*40 SETUPFIL,INFILE
      CHARACTER*78 MSGTXT
      DATA BLANK /'        '/
C
C       ** INITIALIZE AND SET THE DATA TYPE
C
      FIELDS = BLANK
 100  CONTINUE
C
C       ** DISABLE THE FUNCTION KEYS F5 (CLEAR FORM) AND F6 (CLEAR FIELD)
C 
      RTNFLAG = 'FA'
      CALL LOCATE(12,22,IERR)
      CALL GETLFRM('LSTKEFRM',' ',FIELDS,22,RTNFLAG)
      IF (RTNFLAG.EQ.'4F') GO TO 145
C
C       ** MAKE SURE ALL FIELDS HAVE BEEN ENTERED
C
      IF (FIELDS.EQ.' ') THEN
          CALL BEEP
          GO TO 100
      END IF
C
C       ** RETRIEVE THE FIELDS FROM THE USER
C
      INFILE = ' '    
      LGTH = LNG(FIELDS)
      IF (FIELDS(LGTH:LGTH).NE.'\') THEN
          INFILE = FIELDS(1:LGTH)//'\'
      ELSE
          INFILE = FIELDS(1:LGTH)
      END IF
      LGTH = LNG(INFILE)
      SETUPFIL=INFILE(1:LGTH)//'SETUP.DAT'
C
C       ** CALCULATE THE RECORD LENGTH FOR THE SETUP.DAT FILE
C
      IRECLEN = 18 + 2*40 + 5*2
C
C       ** OPEN THE SETUP.DAT FILE TO GET INFORMATION OF THE KEY-ENTRY FORM
C
      OPEN (5,FILE=SETUPFIL,STATUS='OLD',ACCESS='DIRECT'
     +      ,RECL=IRECLEN,SHARE='DENYWR',MODE='READ',IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         WRITE(MSGTXT,'(A20,I5)') SETUPFIL,IOCHK
         CALL WRTMSG(4,157,12,1,1,MSGTXT,25)
         GO TO 100
      END IF
C
      CALL CLS
      CALL LOCATE(0,0,IERR)
      CALL WRTSTR(' Datatype   Dataset',19,15,1)
      IROW = 1
      ICOL = 1
      DO 125 IREC = 1,999
         READ(5,REC=IREC,ERR=135) DELMARK,INTYPE,INDDS,NUMELEM
         IF (DELMARK.EQ.BLANK) THEN
            IF (IROW.GT.20) THEN
               CALL LOCATE(23,1,IERR)
               CALL WRTMSG(2,202,11,0,0,' ',0)
               CALL GETCHAR(0,INCHAR)
               IF (INCHAR.EQ.'4F') THEN
                  GO TO 145
               END IF
               CALL CLS
               CALL LOCATE(0,0,IERR)
               CALL WRTSTR(' Datatype   Dataset',19,15,1)
               IROW = 1
           END IF
           IROW = IROW + 1   
           CALL LOCATE(IROW,3,IERR)
           CALL WRTSTR(INTYPE,3,14,0) 
           CALL WRTSTR(BLANK,8,14,0)
           CALL WRTSTR(INDDS,3,14,0)
        END IF
  125 CONTINUE
  135 CONTINUE
      CALL WRTMSG(2,202,11,0,0,' ',0)
      CALL GETCHAR(0,INCHAR)
  145 CONTINUE
      CLOSE(5)
      RETURN
      END
